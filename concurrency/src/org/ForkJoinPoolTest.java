package org;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.TimeUnit;

/**
 * JDK 7.0
 * An special implementation of ExecutorService interface. extension of AbstractExecutorService
 * Helps to get advantage of multi processor/core (work for tasks that can be broken into smaller pieces recursivly)
 * => Aim to use the all processing power to enhance performance
 * <p>
 * * Fork -> split the work as subTasks until they are simple enough(divide-and-conquer algorithm)
 * * distirbutes tasks in a thread pool, as per work-stealing algorithm(free threads steal work from other threads which are busy)
 * * Keeps no worker thread ideal
 * Join -> Join the subTasks results to get the result of main task (this is a tree type execution)
 * * initial pool size can be set ForkJoinPool(4);. But it adjusts dynamically.
 * No need to shutdown the pool => since all threads are in Demon mode
 *
 * ForkJoinPool submitting tasks
 * -----------------------------1
 * 1) execute() => this is the init. Then fork method is called to split work between threads
 * 2) invoke() => wait for the result
 * 3) submit(0 => return future
 *
 *
 * * ForkJoinPool is an abstract class =>
 * RecursiveAction(=> this does not return a value, compute method) and RecursiveTask(=> return a value from compute method) are the known direct subclasses
 *
 * Difference from ExecutorService
 *  => work-stealing algo
 *  => Whan a task i waiting for the finalization of the sub-tasks it created using join operation => the read looks for other tasks that have not been executed yet and begins
 *  its execution. (so running time is fully optimized)
 *
 * Java8 => java.util.Arrays parallellSort() use RecursiveTask.
 * => Stream.parallel() use ForkJoinPool internally.
 *
 * => ForkJoinPool is not a global solution => only recursive forkable tasks can be optimized through forkJoin pool.
 *
 */

public class ForkJoinPoolTest {

    static ForkJoinPool forkJoinPool = new ForkJoinPool(4); //parallelism is the number of processors

    public static void main(String[] args) {

        //forkable tasks
        FindFileTask system = new FindFileTask("C:\\Windows", "exe");
        FindFileTask apps = new FindFileTask("C:\\Program Files", "exe");
        FindFileTask documents = new FindFileTask("C:\\Documents And Settings", "exe");

        forkJoinPool.execute(system);
        forkJoinPool.execute(apps);
        forkJoinPool.execute(documents);
        do {
            System.out.printf("******************************************\n");
            System.out.printf("Main: Parallelism: %d\n", forkJoinPool.getParallelism());
            System.out.printf("Main: Active Threads: %d\n", forkJoinPool.getActiveThreadCount());
            System.out.printf("Main: Task Count: %d\n", forkJoinPool.getQueuedTaskCount());
            System.out.printf("Main: Steal Count: %d\n", forkJoinPool.getStealCount());
            System.out.printf("******************************************\n");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } while ((!system.isDone()) || (!apps.isDone()) || (!documents.isDone()));
        //Shut down ForkJoinPool using the shutdown() method.
        forkJoinPool.shutdown();
        //Write the number of results generated by each task to the console.
        List<String> results;
        results = system.join();
        System.out.printf("System: %d files found.\n", results.size());
        results = apps.join();
        System.out.printf("Apps: %d files found.\n", results.size());
        results = documents.join();
        System.out.printf("Documents: %d files found.\n", results.size());

    }
}

class FindFileTask extends RecursiveTask<List<String>> {

    private final String path;
    private final String extension;

    public FindFileTask(String path, String extension) {
        this.path = path;
        this.extension = extension;
    }

    @Override //compute method should return an object of Generic type of the RecuriveTask
    protected List<String> compute() {

        List<String> list = new ArrayList<String>();
        List<FindFileTask> tasks = new ArrayList<FindFileTask>();

        File file = new File(path);
        File content[] = file.listFiles();

        if (content != null) {
            for (int i = 0; i < content.length; i++) {
                if (content[i].isDirectory()) { //compelx tasks are handed over to new tasks.
                    //when a folder is found => create a new task and fork it(add to the queue)
                    FindFileTask task = new FindFileTask(content[i].getAbsolutePath(), extension);
                    task.fork();
                    //keep track of tasks created by this task.
                    tasks.add(task);
                }
                else { //only simple execution are done by this task
                    //if the extension matches => add to the list
                    if (content[i].getName().endsWith(extension)) {
                        list.add(content[i].getAbsolutePath());
                    }
                }
            }
        }
        //add to the list of files the results returned by the subtasks launched by this task.
        for (FindFileTask item : tasks) {
            list.addAll(item.join());
        }
        //Return the list of strings
        return list;
    }

}